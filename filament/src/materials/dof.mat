material {
    name : DepthOfField,
    parameters : [
        {
           type : sampler2d,
           name : foreground,
           precision: medium
        },
        {
           type : sampler2d,
           name : background,
           precision: medium
        },
        {
           type : sampler2d,
           name : cocFgBg,
           precision: medium
        },
        {
           type : sampler2d,
           name : tiles,
           precision: medium
        },
        {
           type : float,
           name : bokehAngle,
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        postProcess.vertex.xy = postProcess.normalizedUV;
    }
}

fragment {

#include "dofUtils.fs"


#if defined(TARGET_MOBILE)
#define RING_DENSITY    6.0
#else
#define RING_DENSITY    8.0
#endif

#define RING_COUNT	    4.0
#define SAMPLE_COUNT    ((RING_DENSITY * RING_COUNT * (RING_COUNT - 1.0) + 2.0) * 0.5)

// Enabled by default. Mipmaped taps look a lot better, but do cause some
// aliasing issues which force us to set all sample weights to 1.0
// This is here mostly for debugging.
#define KERNEL_USE_MIPMAP     1

// Experimentally, adding spacial noise is not necessary if KERNEL_USE_MIPMAP is enabled,
// however, noise helps a lot otherwise.
// This is here mostly for debugging.
#define KERNEL_USE_NOISE      0


void dummy(){}

layout(location = 1) out float outAlpha;

float sampleWeight(float coc, float mip) {
#if KERNEL_USE_MIPMAP
    // When mipmaping is used this creates aliasing artifacts around geometry edges.
    // Applying the mip correction factor (as below) helps but doesn't solve the issue.
    // In the end, it's better to just assume equal strength for all samples.
    return 1.0;
#else
    // The contribution of sample is inversely proportional to *it's* area
    // (the larger area, the fainter it is).
    // In theory this factor should be 1 / pi * radius^2, however 1/pi is a constant, and
    // because we divide by the total weight eventually, it can be ommited, in fact, any
    // constant can be used. Here we use MAX_COC_RADIUS * MAX_COC_RADIUS instead of 1/pi,
    // because this allows us to fit in mediump precision.

    // The high resolution pixel radius is sqrt(2) * 0.5.
    // x2 to scale to 1/4 res, x 2^mip for the current mip.
    // ^2 for the area.
    float pixelRadiusSquared = pow(2.0, mip);
    return (MAX_COC_RADIUS * MAX_COC_RADIUS) / (max(coc * coc, pixelRadiusSquared));
#endif
}

float intersection(float border, float absCoc, float mip) {
    // there is very little visible difference, so use the cheaper version on mobile
#if defined(TARGET_MOBILE)
    return saturate((absCoc - border) + 0.5);
#else
    return saturate((absCoc - border) * pow(0.5, mip) + 0.5);
#endif
}

float rcp(float x) {
    return 1.0 / x;
}

/*
 * We use a lot of techniques described in:
 * "Life of a Bokeh" by Guillaume Abadie, SIGGRAPH 2018
 */

void accumulateBackground(inout vec4 background, inout float opacity,
        inout float i, highp vec2 pos, float border, float mip) {
    float coc = textureLod(materialParams_cocFgBg, pos, mip).g;
    vec4 s = textureLod(materialParams_background, pos, mip);
    float inLayer = isBackground(coc);
    float o = cocToAlpha(coc) * inLayer;
    float w = intersection(border, abs(coc), mip) * sampleWeight(coc, mip) * inLayer;
    background += s * w;
    opacity += o;
    i += w;
}

void accumulateForeground(inout vec4 foreground, inout float opacity, inout float i,
        highp vec2 pos, float border, float mip) {
    float coc = textureLod(materialParams_cocFgBg, pos, mip).r;
    vec4 s = textureLod(materialParams_foreground, pos, mip);
    float inLayer = isForeground(coc);
    float o = cocToAlpha(coc) * inLayer;
    float w = intersection(border, abs(coc), mip) * sampleWeight(coc, mip) * inLayer;
    foreground += s * w;
    opacity += o;
    i += w;
}

void accumulateBackgroundCenter(inout vec4 background, inout float opacity, inout float i,
        highp vec2 pos, float border, float mip) {
    accumulateBackground(background, opacity, i,pos, border, mip);
}

void accumulateForegroundCenter(inout vec4 foreground, inout float opacity, inout float i,
        highp vec2 pos, float border, float mip) {
    accumulateForeground(foreground, opacity, i,pos, border, mip);
}

void accumulateBackgroundMirror(inout vec4 background, inout float opacity, inout float i,
highp vec2 center, vec2 offset, float border, float mip) {
    accumulateBackground(background, opacity, i, center + offset, border, mip);
    accumulateBackground(background, opacity, i, center - offset, border, mip);
}

void accumulateForegroundMirror(inout vec4 foreground, inout float opacity, inout float i,
        highp vec2 center, vec2 offset, float border, float mip) {
    // The code below is equivalent to:
    //      accumulateForeground(foreground, opacity, i, center + offset, border, mip);
    //      accumulateForeground(foreground, opacity, i, center - offset, border, mip);
    // but selects the min coc of opposite samples as a way to guess the color occluded by
    // the geometry.

    float coc0 = textureLod(materialParams_cocFgBg, center + offset, mip).r;
    vec4 s0 = textureLod(materialParams_foreground, center + offset, mip);
    float coc1 = textureLod(materialParams_cocFgBg, center - offset, mip).r;
    vec4 s1 = textureLod(materialParams_foreground, center - offset, mip);
    float coc = min(coc0, coc1);
    float inLayer = isForeground(coc);
    float o = cocToAlpha(coc) * inLayer * 2.0;  // we're accumulating 2 samples
    float w = intersection(border, abs(coc), mip) * sampleWeight(coc, mip) * inLayer;
    foreground += s0 * w;
    foreground += s1 * w;
    opacity += o;
    i += w * 2.0;
}

float getMipLevel(float kernelSize) {
#if KERNEL_USE_MIPMAP
    float mip = log2(kernelSize * rcp(RING_COUNT + 0.5));
    return mip;
#else
    return 1.0;
#endif
}

void initRing(float i, float kernelSize,
        out float border, out float count, out vec4 r, out vec2 p) {
    float radius = (kernelSize / RING_COUNT) * i;
    border = radius;
    count = max(1.0, RING_DENSITY * i);

    float inc = 2.0 * PI / count;
    vec2 t = vec2(cos(inc), sin(inc));
    float firstSamplePosition = mod(i, 2.0) * 0.5 * inc;

    r = vec4(t.x, -t.y, t.y, t.x);
    p = radius * vec2(cos(firstSamplePosition), sin(firstSamplePosition));
}


void postProcess(inout PostProcessInputs postProcess) {
    highp vec2 uv = variable_vertex.xy;
    vec2 tiles = textureLod(materialParams_tiles, uv, 0.0).rg;

    /*
     * Tiles that are neither foreground or background (in focus) can be skipped
     */

    if (isTrivialTile(tiles)) {
        postProcess.color = vec4(0.0);
        outAlpha = 0.0;
        return;
    }

    vec4 foreground = vec4(0.0);
    vec4 background = vec4(0.0);

    // we use the full resolution pixel size because that's the unit the CoC is in
    highp vec2 fullResPixelSize = 0.5 / vec2(textureSize(materialParams_foreground, 0));

#if KERNEL_USE_NOISE
    // When using mipmaping the noise seems to hurt more than it helps
    float randomAngle = random(gl_FragCoord.xy) * (2.0 * PI);
    float random01 = random(gl_FragCoord.xy * vec2(7.0, 11.0));
    vec2  randomUniformDisk = 0.5 * sqrt(random01) * vec2(cos(randomAngle), sin(randomAngle));
    vec2  noise = randomUniformDisk * rcp(RING_COUNT + 0.5);
#else
    const vec2 noise = vec2(0.0);
#endif

    if (isFastTile(tiles)) {
        // for a foreground tile, the kernel size is the largest CoC radius
        float coc = abs(tiles.r);
        float kernelSize = coc;
        float mip = getMipLevel(kernelSize);
        vec2 uvCenter = uv + noise * kernelSize * fullResPixelSize;

        for (float i = 0.0; i < RING_COUNT; i += 1.0) {

            float border, count;
            vec2 p;
            vec4 r;

            initRing(i, kernelSize, border, count, r, p);

            for (float j = 0.0; j < count; j += 1.0) {
                vec2 pos = uvCenter + p * fullResPixelSize;
                foreground += textureLod(materialParams_foreground, pos, mip);
                p = vec2(dot(p, r.xy), dot(p, r.zw));
            }
        }
        foreground *= rcp(SAMPLE_COUNT);
        //foreground.b += 0.1;
#if POST_PROCESS_OPAQUE
        // kill the work performed above
        foreground.a = 0.0;
#endif
        postProcess.color  = foreground;
        outAlpha           = 1.0;
        return;
    }

    /*
     * Then process the slow foreground / background tiles
     */

    float fgOpacity = 0.0;
    float bgOpacity = 0.0;

    if (isForegroundTile(tiles)) {
        // for a foreground tile, the kernel size is the largest CoC radius
        float kernelSize = -tiles.g;
        float mip = getMipLevel(kernelSize);
        vec2 uvCenter = uv + noise * kernelSize * fullResPixelSize;
        float c = 0.0;

        // the center sample is handled separatly, since it's by itself
        accumulateForegroundCenter(foreground, fgOpacity, c, uvCenter, 0.0, mip);

        for (float i = 1.0; i < RING_COUNT; i += 1.0) {

            float border, count;
            vec2 p;
            vec4 r;

            initRing(i, kernelSize, border, count, r, p);

            for (float j = 0.0; j < count; j += 2.0) {
                accumulateForegroundMirror(foreground, fgOpacity, c,
                        uvCenter, p * fullResPixelSize, border, mip);
                p = vec2(dot(p, r.xy), dot(p, r.zw));
            }
        }
        foreground *= c < MEDIUMP_FLT_MIN ? 0.0 : rcp(c);
        fgOpacity  *= c < MEDIUMP_FLT_MIN ? 0.0 : rcp(SAMPLE_COUNT);
        //foreground.r += 0.1;
    }

    if (isBackgroundTile(tiles)) {
        vec2 centerCoc  = textureLod(materialParams_cocFgBg, uv, 0.0).rg;
        float kernelSize = abs(centerCoc.g);
        float mip = getMipLevel(kernelSize);
        vec2 uvCenter = uv + noise * kernelSize * fullResPixelSize;
        float c = 0.0;

        // the center sample is handled separatly, since it's by itself
        accumulateBackgroundCenter(background, bgOpacity, c, uvCenter, 0.0, mip);

        for (float i = 1.0; i < RING_COUNT; i += 1.0) {

            float border, count;
            vec2 p;
            vec4 r;

            initRing(i, kernelSize, border, count, r, p);

            for (float j = 0.0; j < count; j += 2.0) {
                accumulateBackgroundMirror(background, bgOpacity, c,
                        uvCenter, p * fullResPixelSize, border, mip);
                p = vec2(dot(p, r.xy), dot(p, r.zw));
            }
        }
        background *= c < MEDIUMP_FLT_MIN ? 0.0 : rcp(c);
        bgOpacity  *= c < MEDIUMP_FLT_MIN ? 0.0 : rcp(SAMPLE_COUNT);
        //background.g += 0.1;
    }

#if POST_PROCESS_OPAQUE
    // kill the work performed above
    foreground.a = 0.0;
    background.a = 0.0;
#endif

    // composite the foreground and background layers together.
    // the downside of doing this is that we couldn't use a different upscaler for each
    // layer, but this is a lot less costly

    foreground *= fgOpacity;
    background *= bgOpacity;
    postProcess.color = foreground + (1.0 - fgOpacity) * background;
    outAlpha          = fgOpacity  + (1.0 - fgOpacity) * bgOpacity;
}

}
